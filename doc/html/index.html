<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Support Class Library: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Support Class Library
   </div>
   <div id="projectbrief">A set of tools providing classes and utility</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Support Class Library Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md0">Work In Progress</a></li>
<li class="level1"><a href="#autotoc_md1">Presentation</a></li>
<li class="level1"><a href="#autotoc_md2">Parts</a><ul><li class="level2"><a href="#autotoc_md3">Stream</a><ul><li class="level3"><a href="#autotoc_md4">Comparison with pure STL</a></li>
<li class="level3"><a href="#autotoc_md5">Design</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="autotoc_md0"></a>
Work In Progress</h1>
<h1><a class="anchor" id="autotoc_md1"></a>
Presentation</h1>
<p>The Support Class Library (or SCL, formerly named Standard Class Library as a nod to the STL) is a library built on top of the STL and wants to provide tools and interfaces for common problems and patterns in order to make application development easier.</p>
<h1><a class="anchor" id="autotoc_md2"></a>
Parts</h1>
<h2><a class="anchor" id="autotoc_md3"></a>
Stream</h2>
<p>The stream API is a library that allows lazy evaluation of potentially infinite sequences of data in an easy to write and easy to extend fashion.</p>
<h3><a class="anchor" id="autotoc_md4"></a>
Comparison with pure STL</h3>
<p>For instance, a recurrent task is to filter through a collection and execute an action on the filtered elements, let's compare how one would approach this task in both pure STL and using <code><a class="el" href="namespacescl_1_1stream.html" title="Namespace of the stream API. ">scl::stream</a></code>.</p>
<p>We will assume that the data is initially stored in a <code>std::vector</code>.</p>
<h4>Pure STL solution</h4>
<div class="fragment"><div class="line">template &lt;class Predicate, class Action&gt;</div><div class="line">void processActionIf(Predicate predicate, Action action){</div><div class="line">    std::vector&lt;std::shared_ptr&lt;GuiComponent&gt;&gt; components = GUI.getComponents();</div><div class="line">    for(GuiComponent&amp; component : components){</div><div class="line">        if(predicate(component))</div><div class="line">            action(component);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line">// OR</div><div class="line"></div><div class="line">template &lt;class Predicate, class Action&gt;</div><div class="line">void processActionIf(Predicate predicate, Action action){</div><div class="line">    std::vector&lt;std::shared_ptr&lt;GuiComponent&gt;&gt; components = GUI.getComponents();</div><div class="line">    std::vector&lt;std::shared_ptr&lt;GuiComponent&gt;&gt; filtered;</div><div class="line"></div><div class="line">    std::copy_if(begin(components), end(components), emplace_back(filtered), predicate);</div><div class="line">    std::for_each(begin(filtered), end(filtered), action);</div><div class="line">}</div></div><!-- fragment --><p>In this simple use-case, using a for-loop reduces the amount of unnecessary copies that the otherwise functional-ish code would make. But things can get quite messy with a for-loop : conditions in conditions, chains of conditions, etc... . With the stream API, we want to get the best of both world : expressive and as efficient as a single for-loop.</p>
<h4>Stream API</h4>
<div class="fragment"><div class="line">template &lt;class Predicate, class Action&gt;</div><div class="line">void processActionIf(Predicate predicate, Action action){   </div><div class="line">    streamFrom(GUI.getComponents())</div><div class="line">    | filter(predicate)</div><div class="line">    | forEach(action);</div><div class="line">}</div></div><!-- fragment --><p>Here we get a lot of advantages :</p>
<ul>
<li>Because it has been developped with knowledge of what we encounter in C++, we do not have the "begin&amp;end iterators" issues : we simply pass a container and use it as the data source</li>
<li>We gain in expressiveness : <code>filter</code> expresses more intent than <code>copy_if</code> (because <code>copy_if</code> was not the actual intent, we used it to filter and use the result afterward)</li>
<li>We gain in clarity : Loops can get messy, we can mismatch types. Here no type is specified for the components container nor the components themselves (this is true even when there's a lot to process, where loops could get messier)</li>
<li>We gain in readability : <code>streamFrom</code> is where we begin the sequence processing, <code>|</code> indicate the start of a new operation, <code>;</code> ends the sequence processing</li>
</ul>
<h3><a class="anchor" id="autotoc_md5"></a>
Design</h3>
<p>The library is greatly inspired by rangev3, Rust's <code>iter</code>, JS functional methods for arrays, the JS library <code>sequency</code> and Java 8's Stream API.</p>
<h4>Why free functions and operators instead of methods?</h4>
<p>In addition to the looks of it, using free functions and operators instead of methods provide one really important selling point : extendability.</p>
<p>With methods, if you want to add an operation for streams you would have to :</p>
<ul>
<li>Create a class that inherits from <code><a class="el" href="classscl_1_1stream_1_1_stream.html" title="Class representing a stream of data. ">scl::stream::Stream</a></code></li>
<li>Add your methods</li>
<li>Tell the people that want to use your operation to use your class instead of <code><a class="el" href="classscl_1_1stream_1_1_stream.html" title="Class representing a stream of data. ">scl::stream::Stream</a></code></li>
</ul>
<p>One could argue that with some runtime polymorphism shenanigans provided by the base class we could achieve something similar but it would be painful for the SCL maintainers and probably for the library maintainers.</p>
<p>Using free functions, to add an operation, all you have to do is :</p>
<ul>
<li>Create an appropriate stream iterator class (if needed)</li>
<li>Create a toolbox/type tag (if needed)</li>
<li>Create the free function</li>
<li>Create the <code>operator|</code> overload for your toolbox/type tag (if needed)</li>
</ul>
<p>The pain is where it should be, on the library maintainers' side. Honestly, pain is a bit of an exageration.</p>
<p>You can have a look at <code>filter</code>/<code>map</code> to see how an operator is built from the ground up.</p>
<p>You can have a look at <code>unique</code> to see how an operator is built on top of another one.</p>
<h4>What is the cost?</h4>
<p>Let's say you have</p>
<div class="fragment"><div class="line">std::vector&lt;SpecialElement&gt; v = streamFrom(container)</div><div class="line">| map(&amp;Element::getSpecialId)</div><div class="line">| unique()</div><div class="line">| filter(startsWith(&quot;s&quot;, Case::INSENSITIVE))</div><div class="line">| map(+[](const SpecialId&amp; id){ return SpecialHub::from(id, Checks::NONE); })</div><div class="line">| pack::toVector();</div></div><!-- fragment --><p>This is roughly equivalent to</p>
<div class="fragment"><div class="line">std::vector&lt;SpecialElement&gt; v;</div><div class="line">std::set&lt;SpecialId&gt; tagged;</div><div class="line"></div><div class="line">auto superSpecial = startsWith(&quot;s&quot;, Case::INSENSITIVE);</div><div class="line">for(auto&amp;&amp; e : container){</div><div class="line">    SpecialId id = e.getSpecialId();</div><div class="line">    if(tagged.count(id))</div><div class="line">        continue;</div><div class="line">    else</div><div class="line">        tagged.insert(id);</div><div class="line"></div><div class="line">    if(!superSpecial(id))</div><div class="line">        continue;</div><div class="line"></div><div class="line">    v.emplace_back(SpecialHub::from(id, Checks::NONE));</div><div class="line">}</div></div><!-- fragment --><p>"roughly" because we need to take in account the iterators lifetime as well as the space and state they may use.</p>
<p>Because they are all objects, the state is limited to the lifetime of the iterators/streams and cannot be accessed outside unlike <code>tagged</code> and <code>superSpecial</code>. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
