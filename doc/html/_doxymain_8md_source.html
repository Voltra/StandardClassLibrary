<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Support Class Library: Doxymain.md Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Support Class Library
   </div>
   <div id="projectbrief">A set of tools providing classes and utility</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Doxymain.md</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;[TOC]</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;# Work In Progress</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;# Presentation</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;The Support Class Library (or SCL, formerly named Standard Class Library as a nod to the STL) is a library built on top of the STL and wants to provide tools and interfaces for common problems and patterns in order to make application development easier.</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;# Parts</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;## Stream</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;The stream API is a library that allows lazy evaluation of potentially infinite sequences of data in an easy to write and easy to extend fashion. </div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;### Comparison with pure STL</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;For instance, a recurrent task is to filter through a collection and execute an action on the filtered elements, let&#39;s compare how one would approach this task in both pure STL and using `scl::stream`.</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;We will assume that the data is initially stored in a `std::vector`.</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;#### Pure STL solution</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;```</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;template &lt;class Predicate, class Action&gt;</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;void processActionIf(Predicate predicate, Action action){</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;   std::vector&lt;std::shared_ptr&lt;GuiComponent&gt;&gt; components = GUI.getComponents();</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;   for(GuiComponent&amp; component : components){</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;       if(predicate(component))</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;           action(component);</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;   }</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;}</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;// OR</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;template &lt;class Predicate, class Action&gt;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;void processActionIf(Predicate predicate, Action action){</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;   std::vector&lt;std::shared_ptr&lt;GuiComponent&gt;&gt; components = GUI.getComponents();</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;   std::vector&lt;std::shared_ptr&lt;GuiComponent&gt;&gt; filtered;</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;   </div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;   std::copy_if(begin(components), end(components), emplace_back(filtered), predicate);</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;   std::for_each(begin(filtered), end(filtered), action);</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;}</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;```</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;In this simple use-case, using a for-loop reduces the amount of unnecessary copies that the otherwise functional-ish code would make. But things can get quite messy with a for-loop : conditions in conditions, chains of conditions, etc... . With the stream API, we want to get the best of both world : expressive and as efficient as a single for-loop.</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;#### Stream API</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;```</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;template &lt;class Predicate, class Action&gt;</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;void processActionIf(Predicate predicate, Action action){  </div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;   streamFrom(GUI.getComponents())</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;   | filter(predicate)</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;   | forEach(action);</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;}</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;```</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;Here we get a lot of advantages :</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;* Because it has been developped with knowledge of what we encounter in C++, we do not have the &quot;begin&amp;end iterators&quot; issues : we simply pass a container and use it as the data source</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;* We gain in expressiveness : `filter` expresses more intent than `copy_if` (because `copy_if` was not the actual intent, we used it to filter and use the result afterward)</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;* We gain in clarity : Loops can get messy, we can mismatch types. Here no type is specified for the components container nor the components themselves (this is true even when there&#39;s a lot to process, where loops could get messier)</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;* We gain in readability : `streamFrom` is where we begin the sequence processing, `|` indicate the start of a new operation, `;` ends the sequence processing</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;### Design</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;The library is greatly inspired by rangev3, Rust&#39;s `iter`, JS functional methods for arrays, the JS library `sequency` and Java 8&#39;s Stream API.</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;#### Why free functions and operators instead of methods?</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;In addition to the looks of it, using free functions and operators instead of methods provide one really important selling point : extendability.</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;With methods, if you want to add an operation for streams you would have to :</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;* Create a class that inherits from `scl::stream::Stream`</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;* Add your methods</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;* Tell the people that want to use your operation to use your class instead of `scl::stream::Stream`</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;One could argue that with some runtime polymorphism shenanigans provided by the base class we could achieve something similar but it would be painful for the SCL maintainers and probably for the library maintainers.</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;Using free functions, to add an operation, all you have to do is :</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;* Create an appropriate stream iterator class (if needed)</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;* Create a toolbox/type tag (if needed)</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;* Create the free function</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;* Create the `operator|` overload for your toolbox/type tag (if needed)</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;The pain is where it should be, on the library maintainers&#39; side. Honestly, pain is a bit of an exageration.</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;You can have a look at `filter`/`map` to see how an operator is built from the ground up.</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;You can have a look at `unique` to see how an operator is built on top of another one.</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;#### What is the cost?</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;Let&#39;s say you have</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;```</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;std::vector&lt;SpecialElement&gt; v = streamFrom(container)</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;| map(&amp;Element::getSpecialId)</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;| unique()</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;| filter(startsWith(&quot;s&quot;, Case::INSENSITIVE))</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;| map(+[](const SpecialId&amp; id){ return SpecialHub::from(id, Checks::NONE); })</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;| pack::toVector();</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;```</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;This is roughly equivalent to</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;```</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;std::vector&lt;SpecialElement&gt; v;</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;std::set&lt;SpecialId&gt; tagged;</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;auto superSpecial = startsWith(&quot;s&quot;, Case::INSENSITIVE);</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;for(auto&amp;&amp; e : container){</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;    SpecialId id = e.getSpecialId();</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;    if(tagged.count(id))</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;        continue;</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;    else</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;        tagged.insert(id);</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;    </div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;    if(!superSpecial(id))</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;        continue;</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;    </div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;    v.emplace_back(SpecialHub::from(id, Checks::NONE));</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;}</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;```</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;&quot;roughly&quot; because we need to take in account the iterators lifetime as well as the space and state they may use.</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;Because they are all objects, the state is limited to the lifetime of the iterators/streams and cannot be accessed outside unlike `tagged` and `superSpecial`.</div></div><!-- fragment --></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
